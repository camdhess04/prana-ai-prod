// src/services/workoutService.ts
// V1.5.4 Update: Final attempt with stricter types, explicit guards, no subscription types

// Import only GraphQLResult, not the union type if possible
import { generateClient, type GraphQLResult } from 'aws-amplify/api';
import {
    // Mutations
    createWorkoutTemplate, createExercise, deleteWorkoutTemplate, deleteExercise,
    createWorkoutSession, updateScheduledWorkout
} from '../graphql/mutations';
import {
    // Queries
    getWorkoutTemplate,
    getScheduledWorkout
    // Using custom queries for lists
} from '../graphql/queries';
import {
    // API Types - Ensure these were correctly generated by 'amplify codegen'
    CreateWorkoutTemplateInput, CreateExerciseInput, DeleteWorkoutTemplateInput, DeleteExerciseInput,
    WorkoutTemplate as APIWorkoutTemplate, Exercise as APIExercise, WorkoutSession as APIWorkoutSession,
    ScheduledWorkout as APIScheduledWorkout,
    CreateWorkoutSessionInput, UpdateScheduledWorkoutInput,
    SessionExerciseInput, PerformedSetInput, // Includes rpe/notes
    GetWorkoutTemplateQuery, GetScheduledWorkoutQuery,
    CreateWorkoutTemplateMutation, CreateExerciseMutation, DeleteWorkoutTemplateMutation, DeleteExerciseMutation, CreateWorkoutSessionMutation, UpdateScheduledWorkoutMutation
} from '../API';
// Import local TS types - Assume these are now CORRECTLY updated
import { WorkoutTemplate, Exercise, WorkoutSession, SessionExercise, PerformedSet, LogExercise } from '../types/workout';

const client = generateClient();

// Custom Queries defined inline - Ensure performedSets selects rpe/notes
const listTemplatesByUserIdWithExercises = /* GraphQL */ `
  query TemplatesByUserId($userId: ID!, $filter: ModelWorkoutTemplateFilterInput, $limit: Int, $nextToken: String) {
    templatesByUserId(userId: $userId, filter: $filter, limit: $limit, nextToken: $nextToken) {
      items { id userId name description isAIPlan createdAt updatedAt owner _version _deleted _lastChangedAt __typename
        exercises(limit: 100) { items { id name sets reps weight restPeriod note createdAt _version __typename } nextToken __typename }
      } nextToken __typename
    }
  }`;
const listSessionsByUserIdWithDetails = /* GraphQL */ `
  query SessionsByUserId($userId: ID!, $completedAt: ModelStringKeyConditionInput, $filter: ModelWorkoutSessionFilterInput, $limit: Int, $nextToken: String) {
    sessionsByUserId(userId: $userId, completedAt: $completedAt, filter: $filter, limit: $limit, nextToken: $nextToken, sortDirection: DESC) {
      items { id userId templateId scheduledWorkoutId name duration completedAt owner createdAt updatedAt _version _deleted _lastChangedAt __typename
        exercises { id name note __typename performedSets { id reps weight rpe notes __typename } }
      } nextToken __typename
    }
  }`;

// Helper Type Guards - More specific
function hasGraphQLErrors<T>(obj: GraphQLResult<T>): obj is GraphQLResult<T> & { errors: NonNullable<GraphQLResult<T>['errors']> } {
    // Check for the 'errors' property specifically
    return !!obj && typeof obj === 'object' && 'errors' in obj && Array.isArray(obj.errors) && obj.errors.length > 0;
}
function hasGraphQLData<T>(obj: GraphQLResult<T>): obj is GraphQLResult<T> & { data: NonNullable<GraphQLResult<T>['data']> } {
     // Check for the 'data' property specifically, and ensure no errors alongside it
    return !!obj && typeof obj === 'object' && 'data' in obj && obj.data !== null && obj.data !== undefined && !hasGraphQLErrors(obj);
}

// Input Type Helper - Ensure local Exercise matches schema (string reps/weight etc)
type CreateWorkoutTemplateData = {
    userId: string; name: string; description?: string | null;
    exercises: Exercise[]; // Uses local Exercise type - ensure it aligns!
    owner: string; isAIPlan?: boolean | null;
};

// --- Template Functions ---
const saveTemplate = async (templateData: CreateWorkoutTemplateData): Promise<WorkoutTemplate> => {
    if (!templateData.owner || !templateData.userId) throw new Error("User identity required");
    if (!templateData.exercises?.length) throw new Error("Exercises required");

    const templateInput: CreateWorkoutTemplateInput = {
        userId: templateData.userId, name: templateData.name, description: templateData.description,
        owner: templateData.owner, isAIPlan: templateData.isAIPlan ?? false
    };
    let savedTemplate: APIWorkoutTemplate;

    try {
        const templateResult = await client.graphql<CreateWorkoutTemplateMutation>({ query: createWorkoutTemplate, variables: { input: templateInput } });
        if (hasGraphQLErrors(templateResult)) throw templateResult.errors[0];
        if (!hasGraphQLData(templateResult) || !templateResult.data.createWorkoutTemplate) throw new Error("Save template metadata failed");
        savedTemplate = templateResult.data.createWorkoutTemplate;
        console.log(`✅ Saved Template Metadata: ${savedTemplate.name} (ID: ${savedTemplate.id})`);

        const exerciseInputPromises = templateData.exercises.map((exercise: Exercise) => { // Explicit type
            const input: CreateExerciseInput = {
                workoutTemplateId: savedTemplate.id, name: exercise.name,
                sets: exercise.sets ?? null, reps: exercise.reps ?? null, weight: exercise.weight ?? null, // Use local type (string | null)
                restPeriod: exercise.restPeriod ?? null, note: exercise.note ?? null, owner: templateData.owner,
            };
            return client.graphql<CreateExerciseMutation>({ query: createExercise, variables: { input } });
        });
        const exerciseResults = await Promise.all(exerciseInputPromises);

        const savedExercises: APIExercise[] = [];
        for (const result of exerciseResults) {
            if (hasGraphQLErrors(result)) throw result.errors[0];
            if (!hasGraphQLData(result) || !result.data.createExercise) throw new Error("An exercise failed to save");
            savedExercises.push(result.data.createExercise);
        }
        console.log(`✅ Saved ${savedExercises.length} exercises for template ${savedTemplate.id}`);

        return { // Map to local type
            id: savedTemplate.id, userId: savedTemplate.userId, name: savedTemplate.name,
            description: savedTemplate.description ?? undefined, isAIPlan: savedTemplate.isAIPlan ?? false,
            exercises: savedExercises.map((ex: APIExercise): Exercise => ({ // Map API -> Local
                id: ex.id, name: ex.name, sets: ex.sets ?? null, reps: ex.reps ?? null, weight: ex.weight ?? null,
                restPeriod: ex.restPeriod ?? undefined, note: ex.note ?? undefined,
            })),
            createdAt: savedTemplate.createdAt, updatedAt: savedTemplate.updatedAt, owner: savedTemplate.owner,
        };
    } catch (error: any) { /* ... error handling ... */ throw error; }
};

const getTemplates = async (userId: string): Promise<WorkoutTemplate[]> => {
    // ... (Keep existing getTemplates logic - ensure mapping matches updated local types) ...
    if (!userId) return [];
     console.log(`Workspaceing templates for user ${userId} via Custom API Query...`);
     try {
         type CustomTemplateItem = Partial<APIWorkoutTemplate> & { _deleted?: boolean | null; exercises?: { items?: (Partial<APIExercise> | null)[] | null } | null };
         type CustomTemplatesQueryResult = { templatesByUserId?: { items?: (CustomTemplateItem | null)[] | null } | null };
         const variables = { userId: userId, filter: { _deleted: { ne: true } } };
         const result = await client.graphql<CustomTemplatesQueryResult>({ query: listTemplatesByUserIdWithExercises, variables: variables });

         if (hasGraphQLErrors(result)) { throw result.errors[0]; }
         const items = result.data?.templatesByUserId?.items ?? [];
         const validItems = items.filter((item): item is APIWorkoutTemplate & { exercises?: { items: (APIExercise | null)[] | null } | null } =>
             !!item && !item._deleted && !!item.id && !!item.userId && !!item.name && !!item.createdAt && !!item.updatedAt
         );
         console.log(`Workspaceed ${validItems.length} non-deleted templates`);

         return validItems.map((item): WorkoutTemplate => {
             const mappedExercises = item.exercises?.items
                 ?.filter((ex): ex is APIExercise => !!ex && !!ex.id && !!ex.name)
                 .map((ex: APIExercise): Exercise => ({
                     id: ex.id, name: ex.name, sets: ex.sets ?? null, reps: ex.reps ?? null, weight: ex.weight ?? null,
                     restPeriod: ex.restPeriod ?? undefined, note: ex.note ?? undefined,
                 })) ?? [];
             return {
                 id: item.id, userId: item.userId, name: item.name, description: item.description ?? undefined,
                 isAIPlan: item.isAIPlan ?? false, // Assumes local type has isAIPlan?
                 exercises: mappedExercises, createdAt: item.createdAt, updatedAt: item.updatedAt, owner: item.owner,
             };
         });
     } catch (error: any) { console.error('Error getting templates:', error); return []; }
};

const deleteTemplate = async (templateId: string, userId: string): Promise<string | null> => {
    // ... (Keep existing delete logic - ensure graphQL call uses specific types) ...
     if (!userId || !templateId) throw new Error("User/Template ID required");
     console.log(`DELETE: Attempting delete for template ${templateId}`);
     try {
         console.log(`DELETE STEP 1: Fetching template version...`);
         const getResult = await client.graphql<GetWorkoutTemplateQuery>({ query: getWorkoutTemplate, variables: { id: templateId } });
         if (hasGraphQLErrors(getResult)) throw getResult.errors[0];
         const current = getResult.data?.getWorkoutTemplate;
         if (!current || current._deleted) return null;
         const version = current._version;
         if (typeof version !== 'number') throw new Error(`Invalid version: ${version}`);
         console.log(`DELETE STEP 1 SUCCESS: Version: ${version}`);

         console.log(`DELETE STEP 2: Querying exercises...`);
         type ExercisesQueryResult = { exercisesByWorkoutTemplateId?: { items?: ({ id: string, _version: number | null } | null)[] | null } | null };
         const listQuery = /* GraphQL */ `query ExercisesByWorkoutTemplateId($workoutTemplateId: ID!) { exercisesByWorkoutTemplateId(workoutTemplateId: $workoutTemplateId, limit: 999) { items { id _version } } }`;
         const exerciseResult = await client.graphql<ExercisesQueryResult>({ query: listQuery, variables: { workoutTemplateId: templateId } });
         if (hasGraphQLErrors(exerciseResult)) throw exerciseResult.errors[0];
         const exercisesToDelete = exerciseResult.data?.exercisesByWorkoutTemplateId?.items ?? [];
         const validExercises = exercisesToDelete.filter((ex): ex is { id: string, _version: number } => !!ex && typeof ex._version === 'number');
         console.log(`DELETE STEP 2: Found ${validExercises.length} exercises.`);

         if (validExercises.length > 0) {
             const deletePromises = validExercises.map(ex => client.graphql<DeleteExerciseMutation>({ query: deleteExercise, variables: { input: { id: ex.id, _version: ex._version } } }));
             const deleteResults = await Promise.all(deletePromises);
             deleteResults.forEach(res => { if (hasGraphQLErrors(res)) throw res.errors[0]; });
             console.log(`DELETE STEP 2 SUCCESS: Deleted ${validExercises.length} exercises.`);
         }

         console.log(`DELETE STEP 3: Deleting WorkoutTemplate ${templateId} (v: ${version})`);
         const deleteInput: DeleteWorkoutTemplateInput = { id: templateId, _version: version };
         const templateDeleteResult = await client.graphql<DeleteWorkoutTemplateMutation>({ query: deleteWorkoutTemplate, variables: { input: deleteInput } });
         if (hasGraphQLErrors(templateDeleteResult)) throw templateDeleteResult.errors[0];
         const deletedId = templateDeleteResult.data?.deleteWorkoutTemplate?.id;
         if (deletedId) { console.log('DELETE STEP 3 SUCCESS:', deletedId); return deletedId; }
         else { console.warn("Delete template response missing ID"); return null; }
     } catch (error: any) { console.error('SERVICE ERROR: deleteTemplate:', error); throw error; }
};


// --- Session Functions ---

type SaveSessionData = { // Ensure this matches data from LogSessionScreen
    userId: string; owner: string; templateId?: string | null;
    scheduledWorkoutId?: string | null; name: string;
    exercises: LogExercise[]; // Assumes LogExercise's PerformedSet aligns with local PerformedSet (string reps/weight)
    duration?: number | null; completedAt: string;
};

const saveSession = async (sessionData: SaveSessionData): Promise<WorkoutSession> => {
    if (!sessionData.userId || !sessionData.owner) throw new Error("User identity required");

    // Map frontend LogExercise[] -> backend SessionExerciseInput[]
    const exercisesForInput: SessionExerciseInput[] = (sessionData.exercises ?? [])
        .filter((ex): ex is LogExercise => !!ex && !!ex.id) // Filter nulls and ensure ID exists
        .map((ex: LogExercise): SessionExerciseInput => ({
            id: ex.id, // Exercise Definition ID
            name: ex.name,
            note: ex.note,
            performedSets: (ex.performedSets ?? [])
                .filter((set): set is PerformedSet => !!set && !!set.id) // Filter nulls and ensure ID exists
                .map((set: PerformedSet): PerformedSetInput => ({ // Map local PerformedSet -> PerformedSetInput
                     id: set.id, // Unique ID for this logged set instance
                     reps: set.reps ?? null,     // Local type should be string | null
                     weight: set.weight ?? null, // Local type should be string | null
                     rpe: set.rpe ?? null,       // Local type should be number | undefined
                     notes: set.notes ?? null,   // Local type should be string | undefined
                }))
        }));

    const input: CreateWorkoutSessionInput = {
        userId: sessionData.userId, templateId: sessionData.templateId,
        scheduledWorkoutId: sessionData.scheduledWorkoutId, name: sessionData.name,
        exercises: exercisesForInput, duration: sessionData.duration,
        completedAt: sessionData.completedAt, owner: sessionData.owner
    };

    let savedSession: APIWorkoutSession;

    try {
        console.log("Saving Session via API with input:", JSON.stringify(input, null, 2));
        const result = await client.graphql<CreateWorkoutSessionMutation>({ query: createWorkoutSession, variables: { input } });

        if (hasGraphQLErrors(result)) { throw result.errors[0]; }
        if (!hasGraphQLData(result) || !result.data.createWorkoutSession) { throw new Error("Save session failed"); }
        savedSession = result.data.createWorkoutSession;
        console.log('✅ Workout session saved via API:', savedSession.name, savedSession.id);

        // Update ScheduledWorkout status if applicable
        if (sessionData.scheduledWorkoutId && savedSession) {
            console.log(`Updating status for ScheduledWorkout ID: ${sessionData.scheduledWorkoutId}`);
            try {
                const getSchedResult = await client.graphql<GetScheduledWorkoutQuery>({ query: getScheduledWorkout, variables: { id: sessionData.scheduledWorkoutId } });
                if (hasGraphQLErrors(getSchedResult)) throw getSchedResult.errors[0];
                const currentSched = getSchedResult.data?.getScheduledWorkout;

                if (!currentSched || currentSched._deleted) {
                    console.warn(`ScheduledWorkout ${sessionData.scheduledWorkoutId} not found/deleted.`);
                } else if (typeof currentSched._version === 'number') {
                     const updateInput: UpdateScheduledWorkoutInput = {
                        id: sessionData.scheduledWorkoutId, status: 'Completed',
                        workoutSessionId: savedSession.id, _version: currentSched._version
                    };
                    const updateResult = await client.graphql<UpdateScheduledWorkoutMutation>({ query: updateScheduledWorkout, variables: { input: updateInput } });
                     if (hasGraphQLErrors(updateResult)) throw updateResult.errors[0];
                     if (!hasGraphQLData(updateResult) || !updateResult.data.updateScheduledWorkout) throw new Error("Update schedule status failed");
                     console.log(`✅ Updated ScheduledWorkout ${sessionData.scheduledWorkoutId} status.`);
                } else { console.error(`Invalid version for ScheduledWorkout ${sessionData.scheduledWorkoutId}`); }
            } catch (scheduleUpdateError: any) {
                 console.error(`❌ Error updating ScheduledWorkout status:`, scheduleUpdateError);
            }
        }

        // Map API result back to local WorkoutSession type
        type APISessionExercise = NonNullable<APIWorkoutSession['exercises']>[0];
        type APIPerformedSet = NonNullable<APISessionExercise['performedSets']>[0];

        return {
            id: savedSession.id, userId: savedSession.userId, templateId: savedSession.templateId,
            scheduledWorkoutId: savedSession.scheduledWorkoutId, name: savedSession.name,
            duration: savedSession.duration, completedAt: savedSession.completedAt,
            exercises: (savedSession.exercises ?? [])
                .filter((ex): ex is APISessionExercise & { id: string, name: string } => !!ex && !!ex.id && !!ex.name)
                .map((ex: APISessionExercise & { id: string, name: string } ): SessionExercise => ({
                    id: ex.id, name: ex.name, note: ex.note,
                    performedSets: (ex.performedSets ?? [])
                        .filter((set): set is APIPerformedSet & { id: string } => !!set && !!set.id)
                        .map((set: APIPerformedSet & { id: string }): PerformedSet => ({
                            id: set.id, reps: set.reps ?? null, weight: set.weight ?? null,
                            rpe: set.rpe ?? undefined, notes: set.notes ?? undefined
                        }))
                })),
            createdAt: savedSession.createdAt, updatedAt: savedSession.updatedAt, owner: savedSession.owner,
        };

    } catch (error: any) { /* ... error handling ... */ throw error; }
};


const getSessionsByUserId = async (userId: string): Promise<WorkoutSession[]> => {
     if (!userId) return [];
     console.log(`Workspaceing sessions for user ${userId} via Custom API Query...`);

     type CustomPerformedSet = Partial<PerformedSetInput> & { id?: string | null, __typename?: string }; // Add typename
     type CustomSessionExercise = { id?: string | null; name?: string | null; note?: string | null; __typename?: string; performedSets?: (CustomPerformedSet | null)[] | null };
     type CustomSessionItem = Partial<APIWorkoutSession> & { __typename?: string; exercises?: (CustomSessionExercise | null)[] | null };
     type CustomSessionsQueryResult = { sessionsByUserId?: { items?: (CustomSessionItem | null)[] | null, __typename?: string } | null }; // Add typename

     try {
         const variables = { userId: userId, filter: { _deleted: { ne: true } } };
         const result = await client.graphql<CustomSessionsQueryResult>({ query: listSessionsByUserIdWithDetails, variables: variables });

         if (hasGraphQLErrors(result)) { throw result.errors[0]; }
         const items = result.data?.sessionsByUserId?.items ?? [];
         const validItems = items.filter((item): item is APIWorkoutSession & { exercises?: (CustomSessionExercise | null)[] | null } =>
             !!item && !item._deleted && !!item.id && !!item.userId && !!item.name && !!item.completedAt && !!item.createdAt && !!item.updatedAt
         );
         console.log(`Workspaceed ${validItems.length} non-deleted sessions`);

         return validItems.map((item): WorkoutSession => ({
             id: item.id, userId: item.userId, templateId: item.templateId, scheduledWorkoutId: item.scheduledWorkoutId,
             name: item.name, duration: item.duration, completedAt: item.completedAt,
             exercises: (item.exercises ?? [])
                 .filter((ex): ex is CustomSessionExercise & { id: string; name: string; } => !!ex && !!ex.id && !!ex.name)
                 .map((ex): SessionExercise => ({
                     id: ex.id, name: ex.name, note: ex.note,
                     performedSets: (ex.performedSets ?? [])
                         .filter((set): set is CustomPerformedSet & { id: string; } => !!set && !!set.id)
                         .map((set): PerformedSet => ({
                             id: set.id, reps: set.reps ?? null, weight: set.weight ?? null,
                             rpe: set.rpe ?? undefined, notes: set.notes ?? undefined
                         }))
                 })),
             createdAt: item.createdAt, updatedAt: item.updatedAt, owner: item.owner,
         }));

     } catch (error: any) { console.error('Error getting sessions:', error); return []; }
};


// --- Placeholder/Unused Functions ---
const saveWorkoutPlan = async (plan: any, userId: string): Promise<any> => Promise.reject("Not implemented");
const getCurrentPlan = async (userId: string): Promise<any | null> => Promise.resolve(null);

// --- Export Service ---
const workoutService = { saveTemplate, getTemplates, deleteTemplate, saveSession, getSessionsByUserId, saveWorkoutPlan, getCurrentPlan };
export default workoutService;